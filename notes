/*
Access modifier help:
Levels go as follows: private < default (no modifier) < protected < public
            Within same class       Within same package     Within child classes        All classes
private     x                       -                       -                           -
empty       x                       x                       -                           -
protected   x                       x                       x                           -
public      x                       x                       x                           x
*/

// This is a collection of things to sort

/*
%title> Title
    removes whitespace within a tag
    <title>    Title    </title> becomes
    <title>Title</title>
%dingen<
%dongen
    becomes
    <dingen></dingen><dongen></dongen>
*/

// What to study for interviews
/*
- polymorphism vs encapsulation
    encapsulation: setting access modifiers for methods/attributes to have them closed off or open from other classes
    polymorphism: extending a class' functionalities to multiple/another class(es)
        eg (enclosure contains an animal - either monkey, bird, ... which inherit from the animal class; typeof functionality)
        more specifically: declaring and object and initiating it with one of its inheriting classes
*/

// Java notes
/*
@Override is an optional annotation, although it does help prevent errors in your code. It overrides a method of the same signature in
    a superclass. In most cases, it's a politeness towards your compiler.
Double literals
    double price = 25.75;
    double price = 25d;
    double coeff = 23_456.75_01;    // Underscores in numeric literals only help readability and serve no other purpose
    double val = 5.015E15;  // 5.015 * 10^15
Literal annotations
    0 prefix = octal; int i = 0156 => 110 decimal
    0x prefix = hex; int i = 0x15 => 21 decimal (0001 0101 binary = 1 5 hex)
    0b prefix = binary; int i = 0b110 => 6 decimal
    d suffix = double; double i = 110d => 110.0 decimal
    f suffix = float; float f = 20f;
    l suffix = long; long l = 200l;

Have a look at interfaces and the (implicitly public) default keyword, or even static
    both add the ability to add funtionality in the interface, without having to write a method in the implementing class
    refrain from instantiating static constant variables in interfaces (use enum instead)
Final keyword in the case of a class definition: prohibits inheritance from this class; eg:
    public final class Childless {}
    public class Child extends Childless {} -> becomes impossible
Interesting to implement is the use of this() in class constructors, this way, you can implement default (or calculated) values for more specific constructors eg:
    public Booze(int glasses) {
        this(glasses, "Beer"); // Default the amount of glasses to beer
    }
    public Booze(int glasses, String name) {
        this.glasses = glasses;
        this.name = name;
    }
	// Keep in mind that this() statements have to be on top of the constructor! Same with super()
	// Also keep in mind that java automatically fills in no-param constructors that call super() in case no constructor was defined
	//  and that super() is automatically called as the first line of a constructor when the user doesn't implement it
All final attributes must be assigned a value by the time the constructor has finished its lines

Formatting strings to create a cutoff or other parsing:
	// 30 characters + " " + 8 characters + " " + 4 characters
	fileContent.add(String.format("%-30s%-8s%-4s",args[1],args[2],args[3]));
*/

// Database notes
/*
file system storage vs (relational) database management systems - file system storage is usually unrelated data stored directly in files while dbms is usually ordered in relational structures
    (also in files if you want to be specific and look into the backend operations)

SELECT COUNT(*) FROM orders
        INNER JOIN order_details
                ON orders.order_id = order_details.order_id
        WHERE orders.ship_name = 'QUICK-Stop'
                AND order_details.product_id = 40;
SELECT company_name FROM customers;
SELECT COUNT(*) FROM suppliers
        INNER JOIN products
                ON suppliers.supplier_id = products.supplier_id
        WHERE country = 'USA';
*/
