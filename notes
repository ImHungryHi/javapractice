
/* // Multiple ways to iterate through a HashMap<String, String> (or other) collection
	for (Map.Entry<String, String> entry : map.entrySet()) {
            System.out.println(entry.getKey());
        }

	for (String key : set.keySet()) {
            System.out.println(key + " - " + set.get(key));
        }

	for (String value : map.values()) {
            System.out.println(s);
        }
*/

/* // Performance on LinkedList or ArrayList can vary depending on the type of operation

    public static List getListForGet() {
        return new ArrayList();
    }

    public static List getListForSet() {
        return new ArrayList();
    }

    public static List getListForAddOrInsert() {
        return new LinkedList();
    }

    public static List getListForRemove() {
        return new LinkedList();
    }
*/


/* // HashSet / Set of pets, compare/iterate/remove

package com.codegym.task.task08.task0820;

import java.util.HashSet;
import java.util.Set;
import java.util.*;

/*
Animal set

*/

public class Solution {
    public static void main(String[] args) {
        Set<Cat> cats = createCats();
        Set<Dog> dogs = createDogs();

        Set<Object> pets = join(cats, dogs);
        printPets(pets);

        removeCats(pets, cats);
        printPets(pets);
    }

    public static Set<Cat> createCats() {
        HashSet<Cat> result = new HashSet<Cat>();

        for (int x = 0; x < 4; x++)
            result.add(new Cat());

        return result;
    }

    public static Set<Dog> createDogs() {
        HashSet<Dog> result = new HashSet<Dog>();

        for (int x = 0; x < 3; x++)
            result.add(new Dog());

        return result;
    }

    public static Set<Object> join(Set<Cat> cats, Set<Dog> dogs) {
        Set<Object> pets = new HashSet<Object>(cats);
        Iterator iter = dogs.iterator();

        while (iter.hasNext())
            pets.add(iter.next());

        return pets;
    }

    public static void removeCats(Set<Object> pets, Set<Cat> cats) {
        Iterator iter = pets.iterator();

        while (iter.hasNext()) {
            Object pet = iter.next();
            Iterator catsIter = cats.iterator();

            while (catsIter.hasNext()) {
                Cat cat = (Cat) catsIter.next();

                if (cat.equals(pet))
                    iter.remove();
            }
        }
    }

    public static void printPets(Set<Object> pets) {
        Iterator iter = pets.iterator();

        while (iter.hasNext()) {
            Object pet = iter.next();
            System.out.println(pet);
        }
    }

    public static class Cat {
        // Yep
    }

    public static class Dog {
        // Yep
    }
}
*/


/* // Capitalize substrings from an input & skip double spaces
	BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String s = reader.readLine();
        String[] words = s.split(" ");
        s = "";

        for (String word : words) {
            if (!word.isEmpty()) {
                s += (word.substring(0, 1).toUpperCase() + word.substring(1));

                if (!word.equals(words[words.length - 1]))
                    s += " ";
            }
        }

        System.out.println(s);
*/

/* // Days passed since start of year is odd?
import java.util.Date;
import java.text.SimpleDateFormat;
import java.time.*;
	public static boolean isDateOdd(String date) {
        long diff = 0;

        try {
            SimpleDateFormat df = new SimpleDateFormat("MMMM d yyyy");
            SimpleDateFormat yearFormat = new SimpleDateFormat("yyyy");
            Date dDate = df.parse(date);
            diff = dDate.getTime() - df.parse("JAN 1 " + yearFormat.format(dDate)).getTime();
            diff /= (1000*60*60*24);
            diff--;

            if (diff % 2 != 0)
                return true;
        }
        catch (Exception ex) {
            // Nope, Chuck Testa
        }

        return false;
    }
*/

/* // Month in arraylist (as opposed to the correct way of hashmaps...) - V1 my solution
	BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String input = reader.readLine();

        List<ArrayList> parent = new ArrayList<ArrayList>();
        ArrayList<String> months = new ArrayList<String>();
        ArrayList<Integer> nums = new ArrayList<Integer>();
        months.add("January");
        months.add("February");
        months.add("March");
        months.add("April");
        months.add("May");
        months.add("June");
        months.add("July");
        months.add("August");
        months.add("September");
        months.add("October");
        months.add("November");
        months.add("December");

        for (int x = 1; x <= 12; x++)
            nums.add(x);

        parent.add(nums);
        parent.add(months);

        for (int x = 0; x < 12; x++) {
            int num = Integer.parseInt(parent.get(0).get(x).toString());
            String month = parent.get(1).get(x).toString();

            if (month.equals(input))
                System.out.println(month + " is month " + num);
        }

// V2 apparent solution
	BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        List<String> months = new ArrayList<>();
        months.add("January");
        months.add("February");
        months.add("March");
        months.add("April");
        months.add("May");
        months.add("June");
        months.add("July");
        months.add("August");
        months.add("September");
        months.add("October");
        months.add("November");
        months.add("December");

        String month = reader.readLine();
        if (months.contains(month)) {
            int monthNumber = months.indexOf(month) + 1;
            System.out.println(month + " is month " + monthNumber);
        } else
            System.out.println(month + " isn't a month");
*/

/* // Stack trace operations
	// Get the name of the method that called the current method
	Thread.currentThread().getStackTrace()[2].getMethodName();	// The first element will be "getMethodName", the second is the current method, the third is the previous and so on

	// Get the line number from which the method was called
	return Thread.currentThread().getStackTrace()[2].getLineNumber();

	// Return the stack trace array
	return Thread.currentThread().getStackTrace();

	// If a method10 is called via bunny hopping through method1, return the amount of methods that were called inbetween, including methods 1 and 10
	int stackTraceLength = method1().length - method10().length + 1;

	// Method and class name example
	public static void log(String s) {
        	System.out.println(Thread.currentThread().getStackTrace()[2].getClassName() + ": "
        	    + Thread.currentThread().getStackTrace()[2].getMethodName() + ": "
        	    + s);
    	}
*/

/* // Catch multiple exceptions like this
	try {
		// I solemnly swear that I'm up to no good
	}
	catch (NullPointerException ex) {
		// Do whatever you want to do when a null pointer was encountered
	}
	catch (ArithmeticException ex) {
		// Just don't divide by 0 4Head
	}
	catch (Exception ex) {
		// Last ditch effort to catch any exceptions that weren't caught by the previous catches
	}
*/

/* // You can choose not to catch an exception, but rather throw it like so
	public static void doStuff() throws FileNotFoundException, ClassNotFoundException {}	// If you've included code to read from a file, this method will throw a FileNotFoundException if it's absent
	// You HAVE to try-catch a call to this method in order to compile
*/

/* // Get info from an exception
	try {
            int a = 42 / 0;
        }
        catch (ArithmeticException ex) {
            System.out.println(ex.getMessage());
            System.out.println(ex.getClass().getCanonicalName());
        }
*/

/* // Check which class an object is an instance of, useful with eg exceptions but also in mixed object arrays
	if (exception instanceof RuntimeException) {
		RuntimeException e = (RuntimeException) exception;
		System.out.println(e.getMessage());
	}
*/

/* // inline arrays
	ArrayList<int[]> list = new ArrayList<int[]>();

        list.add(new int[]{1, 2, 3, 4, 5});
        list.add(new int[]{1, 2});
        list.add(new int[]{4, 3, 2, 1});
        list.add(new int[]{0, 0, 0, 0, 0, 0, 0});
        list.add(new int[0]);

        return list;
*/

/* // read from file
	try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            String fileName = reader.readLine();
            reader.close();

            FileInputStream file = new FileInputStream(fileName);

            while (file.available() > 0) {
                System.out.print((char)file.read());
            }

            file.close();
        }
        catch (Exception ex) {
            // Sup?
        }

// write to file from console
	try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            String fileName = reader.readLine();

            BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));

            String input = "";

            do {
                input = reader.readLine();
                writer.write(input);
                writer.newLine();
            } while (!input.equals("exit"));

            reader.close();
            writer.close();
        }
        catch(Exception ex) {
            System.out.println(ex.getMessage());
        }
*/

/* // Homemade sorted add to list
	public static void sortedAdd(ArrayList<Integer> list, int input) {
		boolean added = false;

		for (int i = 0; i < list.size(); i++) {
			if (list.get(i) > input) {
				list.add(i, input);
				added = true;
				break;
			}
		}

		if (!added) {
			list.add(input)
		}
	}
*/